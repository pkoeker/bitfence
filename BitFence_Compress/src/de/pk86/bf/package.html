<HTML>
<HEAD>
  <!-- Created with AOLpress/2.0 -->
  <TITLE>Object Item Service</TITLE>
</HEAD>
<BODY BGCOLOR="#ffffff">
<H1>
  Keyword-Algorithmus (de.pk86.bf)
</H1>
<P>
  <HR>
<H2>
  Einleitung / Problemstellung
</H2>
<P>
Jeder benutzt bei der Recherche im Internet die g&auml;ngigen Suchmaschinen
auf inzwischen selbstverst&auml;ndliche Art und Weise: &nbsp;<BR>
Aus der Menge aller Web-Sites m&ouml;chte ich all die haben, bei denen die
Begriffe "bla" und "blub" aufgef&uuml;hrt sind, aber es sollen alle weglassen
werden, die "blob" enthalten: "bla blub -blob"<BR>
<SMALL>(Das gab letztens&nbsp;mit Google 14600 Resulte bei 0.14 Sekunden
Suchdauer.)</SMALL>
<P>
Da&szlig; die Suchmaschinen recht flott Ergebnisse liefern - selbst bei
komplizierten Abfragen und gro&szlig;en Datenmengen - wird als
selbstverst&auml;ndlich angesehen und ist die Veraussetzung f&uuml;r ihren
Erfolg.
<P>
Nur wie funktioniert sowas?
<P>
Die Aussage "Wird irgendeine gro&szlig;e Datenbank sein!" ist richtig und
falsch zu gleich:<BR>
Daten in einer Datenbank vorzuhalten ist immer eine gute Idee;<BR>
aber wie sieht das mit dem Zugriff auf die Daten aus?
<P>
Die &Uuml;berraschung besteht darin, da&szlig; f&uuml;r die Formulierung
derartiger Such-Abfragen eine relationale Datenbank mit SQL ungeeignet ist,
weil viel zu langsam.
<H2>
  Features
</H2>
<P>
Der hier in Java realisierter Suchalgorithmus ist auf Geschwindigkeit optimiert.
Jede beliebige Abfrage dauert nicht l&auml;nger als wenige Millisekunden.
<P>
Es k&ouml;nnen beliebige "Objekte" definiert werden, die mit beliebigen
"Eigenschaften" versehen sind.
<P>
Auf dieser Basis k&ouml;nne Abfragen bez&uuml;glich der "Eigenschaften"
formuliert und die Ergebnismenge der "Objekte" wird geliefert.
<P>
Welcher Art die Objekte und ihre Eigenschaften dabei sind, bleibt der Phantasie
des Anwenders &uuml;berlassen. Hier ist ein "Objekt" lediglich &uuml;ber
eine numerische Object-ID definiert, und eine "Eigenschaft" als eine Zeichenkette
von bis zu 128 Zeichen.
<H2>
  Begrenzungen
</H2>
<P>
In einem logischen Ausdruck k&ouml;nnen keine Eigenschaften mit Wildcards
eingesetzt werden; also "bl*" f&uuml;r bla, blub, blob etc.
<P>
Die Aufeinanderfolge von Eigenschaften ist dem System unbekannt, es sei denn,
es wird eine Eigenschaft entsprechend definiert:<BR>
Eigenschaften d&uuml;rfen hier auch White Space enthalten: "Meine Eigenschaft";
auf diese Art k&ouml;nnen auch beliebte englische Ausdr&uuml;cke als Eigenschaft
definiert werden: "open source"
<P>
Die Vergleichbarkeit dieser "kleinen" Suchmaschine mit den "gro&szlig;en"
endet damit, da&szlig; derartig riesige Datenmengen nicht problemlos gehandhabt
werden k&ouml;nnen.
<P>
Es wird vermutet, da&szlig; mit diesem Algothimus bis zu 1 Millionen Objekte
mit 40000 Eigenschaften zuverl&auml;ssig und schnell verarbeitet werden
k&ouml;nnen. Die Datenbank wird dann ca. 3 bis 4 GB umfassen.
<P>
Alles was dar&uuml;ber hinaus geht ist eher ein Problem der darunter liegenden
Datenbank, sehr gro&szlig;e Datenbest&auml;nde zu handhaben; vor allem die
Datenbest&auml;nde auf mehrere Rechner zu verteilen. Google behauptet 3 Mrd
Sites indiziert zu haben; es ist unbekannt, wieviele "Eigenschaften" es dabei
gibt (alle Worte aus allen Sprachen dieser Welt!). Das d&uuml;rfte dann wohl
im zweistelling TB-Bereich liegen....
<H2>
  Installation
</H2>
<P>
Das Framework wurde bisher mit MySQL und Postgres getestet ;-)
<H3>
  Datenbank einrichten
</H3>
<P>
Der Datenbank kann ein beliebiger Name gegeben werden.
<P>
<CODE>mysql&gt;create database "myDB";</CODE>
<P>
Die entsprechenden Tabellen anlegen.
<P>
<CODE>mysql&gt;source crebas.sql;</CODE>
<P>
<B>Hinweis:</B><BR>
Die Tabelle "Object" hat in der Tat nur ein einziges Feld "oid"; sollen die
Objekte weitere Informationen halten, wie beispielweise der Dateiname eine
Textdatei, die hier verschlagwortet wurde, dann ist jetzt hierzu Gelegenheit,
in <CODE>crebas.sql</CODE> das Statement "<CODE>Create Table Object ...</CODE>"
entsprechend anzupassen; das Framework selbst wird allerdings immer nur ein
Array von Object-IDs als Ergebnismenge liefern; der &nbsp;Zugriff auf die
weiteren Informationen des Objects mu&szlig; die Anwendung selbst
&uuml;bernehmen.<BR>
Noch ein Hinweis:<BR>
Der Tabellen-Typ bei MySQL mu&szlig; unbedingt innoDB sein! Sonst kann die
Konsistenz der Datenbank nicht gew&auml;hrleistet werden.
<P>
Nach eigenen W&uuml;nschen Benutzer und Rechte einrichten.
<H3>
  Config-File editieren
</H3>
<P>
Die Datei BFConfig.xml enth&auml;lt Einstellungen f&uuml;r die Anwendung:
<P>
<CODE>&lt;?xml version='1.0' encoding='ISO-8859-1'?&gt;<BR>
&lt;Server&gt;<BR>
&nbsp;&lt;Database&gt;<BR>
&nbsp;
&lt;JDBC-Driver&gt;com.mysql.jdbc.Driver&lt;/JDBC-Driver&gt;<BR>
&nbsp;&lt;URL&gt;&lt;![CDATA[jdbc:mysql://localhost:3306/<B>myDB</B>?useUnicode=true&amp;characterEncoding=iso-8859-1]]&gt;&lt;/URL&gt;<BR>
&nbsp; &lt;Username&gt;<B>myUser</B>&lt;/Username&gt;<BR>
&nbsp; &lt;Password&gt;<B>secret</B>&lt;/Password&gt;<BR>
&lt;/Database&gt;<BR>
&lt;Options&gt;<BR>
&nbsp;&lt;MaxOid value="81289"/&gt;<BR>
&nbsp;&lt;MaxResultSet value="1000"/&gt;<BR>
&nbsp;&lt;ResultSetPage
value="20"/&gt;</CODE><BR>
<CODE>&lt;/Options&gt;</CODE>
<P>
<CODE> &lt;!-- GLUE -<BR>
&lt;WebService&gt;<BR>
&nbsp;&lt;URL&gt;http://localhost:8004&lt;/URL&gt;<BR>
&nbsp;&lt;Service&gt;bf&lt;/Service&gt;<BR>
&lt;/WebService&gt;<BR>
--&gt;<BR>
&lt;/Server&gt;</CODE>
<P>
Damit die Anwedung auf die Datenbank zugreifen kann, mu&szlig; selbstredent
ein JDBC-Driver angegeben werden, eine URL unter der die Datenbank erreichbar
ist (und auch l&auml;uft!), Username und Password.
<P>
Mit MaxOid wird die maximale Object-ID f&uuml;r die Anwendung definiert;
dieses sollte ein Vielfaches von 8100 sein.
<P>
MaxResultSet definiert die maximale Gr&ouml;&szlig;e eines ResultSet
(Zwischenergebnisse d&uuml;rfen nat&uuml;rlich beliebig gro&szlig; werden!).
<P>
ResultSetPage ist die Anzahl der Treffer die aus der Ergebnismenge durch
die Methode getNext() geliefert werden.
<H3>
  WebService
</H3>
<P>
Die Anwendung kann auch als WebService mit electric GLUE angeboten werden;
dann ist eine URL und ein Service anzugeben, unter der der Dienst publiziert
wird.
<P>
Der Zugriff auf diesen Dienst vom Client aus geschieht dann wie folgt:
<P>
<CODE>import electric.registry.*;<BR>
import de.pkjs.bf.ObjectItemService;<BR>
...<BR>
ObjectItemService myService =
&nbsp;(ObjectItemService)Registry.bind("http://myServer:8004/bf.wsdl");<BR>
long[] resutSet = myService.execute("bla blub - blob");</CODE><BR>
<CODE>...</CODE>
<H3>
  Architektur
</H3>
<P>
Der hier angebotene Dienst kann direkt &uuml;ber Java-Methodenaufrufe genutzt
werden oder als WebService; die Datenbank kann auf einem weiteren Rechner
laufen. In diesem Sinne handelt es sich hier um eine dienste-orientierte,
verteilte Komponenten-Architektur.
<P>
Au&szlig;er zu Testzwecken sollte dieser Dienst immer als WebService eingerichtet
werden. Wenn m&ouml;glich sollte der Dienst auf dem Datenbank-Server selbst
eingerichtet und dort als WebService publiziert werden; das "Verkehrsaufkommen"
zwischen dem Dienst und der Datenbank d&uuml;rfte h&ouml;her liegen, als
das zwischen Client und WebService.
<H3>
  CLASSPATH
</H3>
<P>
Um den Dienst zu starten, mu&szlig; der Classpath folgende JARs enthalten:
<UL>
  <LI>
    pk86_bf.jar (Das Framework selbst)
  <LI>
    mysql-connector-java.jar (Der JDBC-Driver f&uuml;r MySQL; die Datei kann
    auch anders hei&szlig;en!)
  <LI>
    GLUE-STD.jar (Electric GLUE)
</UL>
<P>
Optionale JARs:
<UL>
  <LI>
    servlet.jar, jnet.jar (Aus der Installation von electric GLUE; nur wenn Dienst
    als Webservice angeboten wird)
  <LI>
    guibuilder.jar (Wenn der JAVA-GuiBuilder als Oberfl&auml;che verwendet wird)
</UL>
<P>
</BODY></HTML>
